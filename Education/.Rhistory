"Valuable during dissection courses",
"Valuable during exam studies",
"Would recommend",
"Worthwhile the investment"
)
# Create the Likert object
overall_experience_likert_object <- likert(overall_experience_likert_data)
# Reorder items manually
overall_experience_order_of_items <- colnames(overall_experience_likert_data)
# Adjust plot to respect the order of items
plot(overall_experience_likert_object) +
ggtitle("Overall Experience") +
theme_minimal() +
scale_x_discrete(limits = rev(overall_experience_order_of_items))
# Define the columns for "Ease of Use" questions
ease_of_use_columns <- c(27, 28, 29, 30, 31, 32)  # Update as needed
# Extract the selected columns for the Likert data
ease_of_use_data <- data[, ease_of_use_columns]
# Convert the columns to factors with ordered levels (assuming a 5-point Likert scale)
ease_of_use_data <- data.frame(lapply(ease_of_use_data, factor,
levels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
ordered = TRUE))
# Create more readable column names for the plot
colnames(ease_of_use_data) <- c("The website is easily accessible",
"The website is structured and clearly arranged",
"The 3D models loaded successfully on my device",
"It took too long to load the models",
"It was easy to navigate the 3D models",
"I prefer the use of a tablet or smartphone over a laptop for this type of tool")
# Create the Likert object
ease_of_use_likert <- likert(ease_of_use_data)
# Reorder items manually
ease_of_use_order_of_items <- colnames(ease_of_use_data)
# Plot the Likert scale responses
plot(ease_of_use_likert) +
ggtitle("Ease of Use") +
theme_minimal() +
scale_x_discrete(limits = rev(ease_of_use_order_of_items))
# Create more readable column names for the plot
colnames(ease_of_use_data) <- c("The website is easily accessible",
"The website is structured and clearly arranged",
"The 3D models loaded successfully on my device",
"It took too long to load the models",
"It was easy to navigate the 3D models",
"Prefer use of a tablet or smartphone over a laptop for this type of tool")
# Create the Likert object
ease_of_use_likert <- likert(ease_of_use_data)
# Reorder items manually
ease_of_use_order_of_items <- colnames(ease_of_use_data)
# Plot the Likert scale responses
plot(ease_of_use_likert) +
ggtitle("Ease of Use") +
theme_minimal() +
scale_x_discrete(limits = rev(ease_of_use_order_of_items))
# Load required libraries
library(readxl)
library(likert)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
library(FSA)
library(knitr)
# Load the data
file_path <- "Data/Use of Real Life 3D Models in Education.xlsx"
sheets <- excel_sheets(file_path)
data_list <- lapply(sheets, function(sheet) read_excel(file_path, sheet = sheet))
data <- data_list[[1]]
print("Column names in data:")
print(colnames(data))
# specify which columns to use for the Likert scale plot
overall_experience <- c(7, 8, 9, 10, 11, 12, 13, 14)
ease_of_use_columns <- c(27, 28, 29, 30, 31, 32)
annot_quiz_columns <- c(21, 22, 23, 24, 25)
lighting_columns <- c(15, 16, 17, 18, 19, 20)
overall_experience_likert_data <- data[, overall_experience]
overall_experience_likert_data$Group <- data[["I am a"]]
# Convert selected columns to factors with ordered levels (5-point Likert scale)
overall_experience_likert_data <- data.frame(lapply(overall_experience_likert_data[, -ncol(overall_experience_likert_data)], factor,
levels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
ordered = TRUE))
# Add the grouping column back to the data frame
overall_experience_likert_data$Group <- data[["I am a"]]
# Create more readable column names for the plot
colnames(overall_experience_likert_data) <- c("Sufficient detail",
"Enhances understanding vs books",
"Enhances understanding vs other 3D software",
"Contributes to learning experience",
"Valuable during dissection courses",
"Valuable during exam studies",
"Would recommend",
"Worthwhile the investment",
"Group")
# Create the Likert object with grouping
overall_experience_likert_object <- likert(overall_experience_likert_data[, -ncol(overall_experience_likert_data)], grouping = overall_experience_likert_data$Group)
# Plot Likert data
plot(overall_experience_likert_object) +
ggtitle("Overall Experience by Group") +
theme_minimal()
# Kruskal-Wallis test for Overall Experience
data_long <- overall_experience_likert_data %>%
pivot_longer(cols = -Group, names_to = "Item", values_to = "Response")
kruskal_test <- function(item_data) {
kruskal.test(Response ~ Group, data = item_data)
}
# Apply the Kruskal-Wallis test to each Likert item
test_results <- data_long %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
mutate(p_value = map_dbl(test, ~.x$p.value)) %>%
select(-data, -test)
# Print Kruskal-Wallis test results
kable(test_results, digits = 3, caption = "Kruskal-Wallis Test Results for Likert Scale Items (Overall Experience)")
# Dunn's test:
dunn_test <- function(item_data) {
dunnTest(Response ~ Group, data = item_data, method = "bonferroni")
}
# Apply Dunn's test to each Likert item where Kruskal-Wallis was significant
posthoc_results <- data_long %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
filter(map_dbl(test, ~.x$p.value) < 0.05) %>%
mutate(posthoc = map(data, dunn_test)) %>%
select(-data, -test)
# Extract and print post-hoc results
posthoc_results_summary <- posthoc_results %>%
mutate(posthoc_summary = map(posthoc, ~ .x$comparisons)) %>%
select(Item, posthoc_summary) %>%
unnest(posthoc_summary)
kable(posthoc_results_summary, digits = 3, caption = "Dunn's Test Pairwise Comparisons (Overall Experience)")
#--------------- Ease of Use:
ease_of_use_likert_data <- data[, ease_of_use_columns]
ease_of_use_likert_data$Group <- data[["I am a"]]
# Convert selected columns to factors with ordered levels (5-point Likert scale)
ease_of_use_likert_data <- data.frame(lapply(ease_of_use_likert_data[, -ncol(ease_of_use_likert_data)], factor,
levels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
ordered = TRUE))
# Add the grouping column back to the data frame
ease_of_use_likert_data$Group <- data[["I am a"]]
# readable column names for the plot
colnames(ease_of_use_likert_data) <- c("The website is easily accessible",
"The website is structured and clearly arranged",
"The 3D models loaded successfully on my device",
"It took too long to load the models",
"It was easy to navigate the 3D models",
"I prefer the use of a tablet or smartphone over a laptop for this type of tool",
"Group")
# Create the Likert object with grouping
ease_of_use_likert_object <- likert(ease_of_use_likert_data[, -ncol(ease_of_use_likert_data)], grouping = ease_of_use_likert_data$Group)
# Plot the Likert data
plot(ease_of_use_likert_object) +
ggtitle("Ease of Use by Group") +
theme_minimal()
# Kruskal-Wallis test for Ease of Use:
data_long_ease <- ease_of_use_likert_data %>%
pivot_longer(cols = -Group, names_to = "Item", values_to = "Response")
# Apply the Kruskal-Wallis test to each Likert item
test_results_ease <- data_long_ease %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
mutate(p_value = map_dbl(test, ~.x$p.value)) %>%
select(-data, -test)
# Print Kruskal-Wallis test results
kable(test_results_ease, digits = 3, caption = "Kruskal-Wallis Test Results for Likert Scale Items (Ease of Use)")
# Apply Dunn's test to each Likert item where Kruskal-Wallis was significant
posthoc_results_ease <- data_long_ease %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
filter(map_dbl(test, ~.x$p.value) < 0.05) %>%
mutate(posthoc = map(data, dunn_test)) %>%
select(-data, -test)
# Extract and print post-hoc results
posthoc_results_summary_ease <- posthoc_results_ease %>%
mutate(posthoc_summary = map(posthoc, ~ .x$comparisons)) %>%
select(Item, posthoc_summary) %>%
unnest(posthoc_summary)
kable(posthoc_results_summary_ease, digits = 3, caption = "Dunn's Test Pairwise Comparisons (Ease of Use)")
#----------------- Annotations and Quiz:
annot_quiz_likert_data <- data[, annot_quiz_columns]
annot_quiz_likert_data$Group <- data[["I am a"]]
# Convert the selected columns to factors with ordered levels (5-point Likert scale)
annot_quiz_likert_data <- data.frame(lapply(annot_quiz_likert_data[, -ncol(annot_quiz_likert_data)], factor,
levels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
ordered = TRUE))
# Add the grouping column back to the data frame
annot_quiz_likert_data$Group <- data[["I am a"]]
# readable column names for the plot
colnames(annot_quiz_likert_data) <- c("Importance of Annotations",
"3D models are useless without annotations",
"Coloured dots are an appropriate method",
"Value of Quizzes",
"Relevance of Quiz Questions",
"Group")
# Create the Likert object with grouping
annot_quiz_likert_object <- likert(annot_quiz_likert_data[, -ncol(annot_quiz_likert_data)], grouping = annot_quiz_likert_data$Group)
# Plot the Likert data
plot(annot_quiz_likert_object) +
ggtitle("Annotations and Quiz by Group") +
theme_minimal()
# Prepare the data for Kruskal-Wallis test for Annotations and Quiz
data_long_annot_quiz <- annot_quiz_likert_data %>%
pivot_longer(cols = -Group, names_to = "Item", values_to = "Response")
# Apply the Kruskal-Wallis test to each Likert item
test_results_annot_quiz <- data_long_annot_quiz %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
mutate(p_value = map_dbl(test, ~.x$p.value)) %>%
select(-data, -test)
# Print Kruskal-Wallis test results
kable(test_results_annot_quiz, digits = 3, caption = "Kruskal-Wallis Test Results for Likert Scale Items (Annotations and Quiz)")
# Apply Dunn's test to each Likert item where Kruskal-Wallis was significant
posthoc_results_annot_quiz <- data_long_annot_quiz %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
filter(map_dbl(test, ~.x$p.value) < 0.05) %>%
mutate(posthoc = map(data, dunn_test)) %>%
select(-data, -test)
# Extract and print post-hoc results
posthoc_results_summary_annot_quiz <- posthoc_results_annot_quiz %>%
mutate(posthoc_summary = map(posthoc, ~ .x$comparisons)) %>%
select(Item, posthoc_summary) %>%
unnest(posthoc_summary)
kable(posthoc_results_summary_annot_quiz, digits = 3, caption = "Dunn's Test Pairwise Comparisons (Annotations and Quiz)")
#---------------- Lighting:
lighting_likert_data <- data[, lighting_columns]
lighting_likert_data$Group <- data[["I am a"]]
# Convert the selected columns to factors with ordered levels
lighting_likert_data <- data.frame(lapply(lighting_likert_data[, -ncol(lighting_likert_data)], factor,
levels = c("Diffuse lighting", "Rather Diffuse lighting", "Equal on both", "Rather Polarized Filter", "Polarized Filter"),
ordered = TRUE))
# Add the grouping column back to the data frame
lighting_likert_data$Group <- data[["I am a"]]
# Create more readable column names for the plot
colnames(lighting_likert_data) <- c("Muscles are easier to recognise",
"Muscles are more defined",
"Arteries and nerves are easier to recognise",
"Has the most detail",
"Is most photorealistic",
"My general preference goes to",
"Group")
# Create the Likert object with grouping
lighting_likert_object <- likert(lighting_likert_data[, -ncol(lighting_likert_data)], grouping = lighting_likert_data$Group)
# Plot the Likert data
plot(lighting_likert_object) +
ggtitle("Polarized filter vs Diffuse lighting by Group") +
theme_minimal()
# Prepare the data for Kruskal-Wallis test for Lighting
data_long_lighting <- lighting_likert_data %>%
pivot_longer(cols = -Group, names_to = "Item", values_to = "Response")
# Apply the Kruskal-Wallis test to each Likert item
test_results_lighting <- data_long_lighting %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
mutate(p_value = map_dbl(test, ~.x$p.value)) %>%
select(-data, -test)
# Print Kruskal-Wallis test results
kable(test_results_lighting, digits = 3, caption = "Kruskal-Wallis Test Results for Likert Scale Items (Lighting)")
# Apply Dunn's test to each Likert item where Kruskal-Wallis was significant
posthoc_results_lighting <- data_long_lighting %>%
group_by(Item) %>%
nest() %>%
mutate(test = map(data, kruskal_test)) %>%
filter(map_dbl(test, ~.x$p.value) < 0.05) %>%
mutate(posthoc = map(data, dunn_test)) %>%
select(-data, -test)
# Extract and print post-hoc results
posthoc_results_summary_lighting <- posthoc_results_lighting %>%
mutate(posthoc_summary = map(posthoc, ~ .x$comparisons)) %>%
select(Item, posthoc_summary) %>%
unnest(posthoc_summary)
kable(posthoc_results_summary_lighting, digits = 3, caption = "Dunn's Test Pairwise Comparisons (Lighting)")
;#------------------
# Manually specify which columns to use for the second Likert scale plot
lighting_columns <- c(15, 16, 17, 18, 19, 20)
# Extract the selected columns for the Likert data
lighting_likert_data <- data[, lighting_columns]
# Convert the selected columns to factors with ordered levels (specified options)
lighting_likert_data <- data.frame(lapply(lighting_likert_data, factor,
levels = c("Diffuse lighting", "Rather Diffuse lighting", "Equal on both", "Rather Polarized Filter", "Polarized Filter"),
ordered = TRUE))
# Create more readable column names for the plot
colnames(lighting_likert_data) <- c("Muscles are easier to recognise",
"Muscles are more defined",
"Arteries and nerves are easier to recognise",
"Has the most detail",
"Is most photorealistic",
"My general preference goes to"
)
# Create the Likert object with grouping
lighting_likert_object <- likert(lighting_likert_data)
# Reorder items manually
lighting_order_of_items <- colnames(lighting_likert_data)
# Adjust plot to respect the order of items
plot(lighting_likert_object) +
ggtitle("Polarized filter vs Diffuse lighting") +
theme_minimal() +
scale_x_discrete(limits = rev(lighting_order_of_items))
#-----------------
# Define the columns for annotations and quiz questions
annot_quiz_columns <- c(21, 22, 23, 24, 25)  # Update as needed
# Extract the selected columns for the Likert data
annot_quiz_data <- data[, annot_quiz_columns]
# Convert the columns to factors with ordered levels (assuming a 5-point Likert scale)
annot_quiz_data <- data.frame(lapply(annot_quiz_data, factor,
levels = c("Strongly Disagree", "Disagree", "Neutral", "Agree", "Strongly Agree"),
ordered = TRUE))
# Create more readable column names for the plot
colnames(annot_quiz_data) <- c("Importance of Annotations",
"3D models are useless without annotations",
"Coloured dots are an appropriate method",
"Value of Quizzes",
"Relevance of Quiz Questions")
# Create the Likert object
annot_quiz_likert <- likert(annot_quiz_data)
# Reorder items manually
annot_quiz_order_of_items <- colnames(annot_quiz_data)
# Plot the Likert scale responses
plot(annot_quiz_likert) +
ggtitle("Annotations and Quiz") +
theme_minimal() +
scale_x_discrete(limits = rev(annot_quiz_order_of_items))
# Load necessary libraries
library(readxl)
library(dplyr)
library(tidyr)
library(ggplot2)
library(reshape2)
library(ggpubr)
library(tidyverse)
library(emmeans)
# Read the data from the Excel file
file_path <- "Data/Use of Real Life 3D Models in Education.xlsx"
data <- read_excel(file_path)
data_orig <- data
# Add ResponderType column to orig data
data <- data %>%
mutate(ResponderType = `I am a`)
# Process ranking data
data_long <- data %>%
# Separate rankings into individual rows
separate_rows(`Rank the following possible future features in order of importance:`, sep = ";") %>%
# unique identifier for each response and its rank
group_by(ID) %>%
mutate(Rank = row_number()) %>%
ungroup() %>%
# Select relevant columns and pivot to a long format
select(ID, ResponderType, Rank, `Rank the following possible future features in order of importance:`) %>%
rename(Feature = `Rank the following possible future features in order of importance:`)
print(head(data_long))
# Heatmap
ggplot(data_long, aes(x = Rank, y = Feature, fill = ResponderType)) +
geom_tile(color = "white") +
scale_fill_brewer(palette = "Set3") +
labs(title = "Rankings per Type of Responder",
x = "Rank",
y = "Feature") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Jitter Plot
ggplot(data_long, aes(x = Rank, y = Feature, color = ResponderType)) +
geom_point(position = position_jitter(width = 0.2, height = 0.2), alpha = 0.7, size = 3) +
scale_color_brewer(palette = "Set1") +
labs(title = "Rankings per Type of Responder",
x = "Rank",
y = "Feature") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
agg_data <- data_long %>%
group_by(ResponderType, Feature) %>%
summarise(Mean_Rank = mean(Rank, na.rm = TRUE), .groups = 'drop')
# ANOVA to test
anova_results <- aov(Rank ~ Feature * ResponderType, data = data_long)
summary(anova_results)
# if there's a significant interaction or main effect
# pairwise comparisons
if (summary(anova_results)[[1]]$`Pr(>F)`[3] < 0.05) {
pairwise_results <- TukeyHSD(anova_results, "Feature:ResponderType")
#print(pairwise_results)
} else {
cat("No significant differences found between responder types.\n")
}
# Convert Tukey HSD results to data frame
# Feature:ResponderType:
tukey_df <- as.data.frame(pairwise_results$`Feature:ResponderType`)
tukey_df$Comparison <- rownames(tukey_df)
if (summary(anova_results)[[1]]$`Pr(>F)`[3] < 0.05) {
pairwise_results <- TukeyHSD(anova_results, "ResponderType")
print(pairwise_results)
} else {
cat("No significant differences found between responder types.\n")
}
# Convert Tukey HSD results to data frame for plotting
# ResponderType:
tukey_df <- as.data.frame(pairwise_results$ResponderType)
tukey_df$Comparison <- rownames(tukey_df)
# Plot Tukey HSD results
ggplot(tukey_df, aes(x = Comparison, y = diff, color = `p adj` < 0.05)) +
geom_point(size = 4) +
geom_errorbar(aes(ymin = lwr, ymax = upr), width = 0.2) +
labs(title = "Tukey HSD Results for Responder Types",
x = "Comparison",
y = "Difference in Mean Rank",
color = "Significant") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Kruskal-Wallis test to find significant differences between type of responders
kruskal_results <- data_long %>%
group_by(Feature) %>%
summarise(p_value = kruskal.test(Rank ~ ResponderType, data = .)$p.value)
print(kruskal_results)
# perform pairwise comparisons using Dunn's test
if (any(kruskal_results$p_value < 0.05)) {
pairwise_results <- data_long %>%
group_by(Feature) %>%
do(pairwise = dunnTest(Rank ~ ResponderType, data = ., method = "bonferroni"))
print(pairwise_results)
}
# Perform simple effects analysis for each feature
emmeans_results <- emmeans(anova_results, pairwise ~ Feature | ResponderType)
emmeans_results
# Print the results
print(emmeans_results)
# Extract the emmeans and contrasts from the emmeans_results
emmeans_data <- as.data.frame(emmeans_results$emmeans)
contrasts_data <- as.data.frame(emmeans_results$contrasts)
# Plot the Estimated Marginal Means (emmeans)
ggplot(emmeans_data, aes(x = Feature, y = emmean, color = ResponderType)) +
geom_point(size = 3) +
geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL), width = 0.2) +
labs(title = "Estimated Marginal Means by Feature and Responder Type",
x = "Feature",
y = "Estimated Mean") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
facet_wrap(~ ResponderType, scales = "free_x")
# Prepare data for the contrasts plot
contrasts_data <- contrasts_data %>%
mutate(Feature1 = sub(" - .*", "", contrast),
Feature2 = sub(".* - ", "", contrast))
# Plot Contrasts
ggplot(contrasts_data, aes(x = Feature1, y = estimate, color = p.value < 0.05)) +
geom_point(size = 3) +
geom_errorbar(aes(ymin = estimate - SE, ymax = estimate + SE), width = 0.2) +
labs(title = "Contrasts of Features within Responder Type",
x = "Feature Comparison",
y = "Estimated Difference",
color = "Significant") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
facet_wrap(~ ResponderType, scales = "free_x")
ranking_column <- "Rank the following possible future features in order of importance:"
rankings <- data_orig[[ranking_column]]
# Split the data into list of character vectors
rankings <- str_split(rankings, ";") %>% map(~ .x[.x != ""])
print(rankings)
rankings_df <- tibble(rankings = rankings) %>%
unnest_wider(rankings, names_sep = "_") %>%
pivot_longer(everything(), names_to = "position", values_to = "feature") %>%
mutate(position = parse_number(position))
print(rankings_df)
# Calculate the average rank for each feature
average_ranks <- rankings_df %>%
group_by(feature) %>%
summarise(average_rank = mean(position))
# Subtract average ranks from 6 (to reverse order)
average_ranks <- average_ranks %>%
mutate(adjusted_rank = 6 - average_rank)
print(average_ranks)
# Plot the adjusted ranks
ggplot(average_ranks, aes(x = reorder(feature, adjusted_rank), y = adjusted_rank)) +
geom_col(fill = "skyblue") +
coord_flip() +
labs(title = "Ranking of Future Features",
x = "Feature",
y = "Average Rank)") +
theme_minimal()
ranking_column <- "Rank the following possible future features in order of importance:"
group_column <- "I am a"
# Extract rankings and group information
rankings <- data_orig[[ranking_column]]
groups <- data_orig[[group_column]]
# Combine rankings and groups into a single data frame
ranking_data <- tibble(
group = groups,
rankings = str_split(rankings, ";") %>% map(~ .x[.x != ""])
)
# Process the ranking data
ranking_data_df <- ranking_data %>%
unnest_wider(rankings, names_sep = "_") %>%
pivot_longer(-group, names_to = "position", values_to = "feature") %>%
mutate(position = parse_number(position))
# Calculate the average rank for each feature within each group
average_ranks <- ranking_data_df %>%
group_by(group, feature) %>%
summarise(average_rank = mean(position), .groups = 'drop') %>%
mutate(adjusted_rank = 6 - average_rank)
print(average_ranks)
# Plot the adjusted ranks grouped by feature
ggplot(average_ranks, aes(x = reorder(feature, adjusted_rank), y = adjusted_rank, fill = group)) +
geom_col(position = "dodge") +
coord_flip() +
labs(title = "Ranking of Future Features by Group",
x = "Feature",
y = "Average Rank") +
theme_minimal()
